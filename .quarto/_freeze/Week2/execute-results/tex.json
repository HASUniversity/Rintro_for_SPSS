{
  "hash": "9fe8724b12fe31f66dec340869a18efd",
  "result": {
    "markdown": "# Posthoctoetsen\n\n## Leerdoelen deze week\n\nMet een **One-way ANOVA** kan je, i.t.t. de onafhankelijke t-toets, meer dan twee groepen met elkaar vergelijken. Je hebt dan één verklarende variabele van nominaal of ordinaal niveau, verdeeld in drie of meer groepen. Je kan dat testen of de groepen van elkaar verschillen. Wil je weten welke groepen onderling van elkaar verschillen, dan doe je dat met een **posthoctoets**.\n\n::: callout-Warning\nJe mag alleen een posthoctoets uitvoeren als uit de anova een significant effect komt. Dus altijd eerst de anova uitvoeren!\n:::\n\nMet een posthoctoets kan je groepen onderling vergelijken. Je voert het uit om te kijken welke groepen onderling significant van elkaar verschillen. Waarom niet gewoon een aantal t-toetsen uitvoeren (je vergelijkt immers telkens twee groepen onderling)? Twee redenen:\n\n-   Ten eerste omdat je op zoek gaat of en waar onderlinge verschillen zitten. En voor al die toetsen bij elkaar wil je de kans op een type-1-fout (ten onrechte H~0~ verwerpen) op 0,05 houden.\n-   Ten tweede omdat je dezelfde data gebruikt om verschillende toetsen uit te voeren.\n\n## Soorten posthoctoetsen\n\nIn de loop van de afgelopen eeuw zijn er heel wat verschillende posthoctoetsen ontwikkeld en is het moeilijk door de bomen het bos te zien. We gebruiken een aantal simpele stelregels:\n\n-   Alle groepen onderling vergelijken:\n    -   Bij ongeveer gelijke groepsgroottes: **Tukey HSD**.\n    -   Bij ongelijke groepsgrootte: **Bonferroni**.\n-   Alleen behandelingen ten opzichte van een controlegroep vergelijken:\n    -   De **Dunnet's** posthoctoets.\n\nHoe voeren we die uit (als voorbeeld met de melkgiftdata, waarbij `fit` het resultaat is van de functie `lm()`)?\n\nEr zijn binnen R veel manieren om posthoctoetsen uit te voeren. Wij gebruiken binnen deze cursus de package **emmeans**, omdat we met deze package alle mogelijke posthoctoetsen kunnen uitvoeren. Wel zo gemakkelijk.\n\nIn dit hoofstuk gebruiken we het voorbeeld van een studie naar melkgift in verschillende koeienrassen:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Week2_files/figure-pdf/unnamed-chunk-1-1.pdf)\n:::\n:::\n\n\n\nJe vindt de dataset op Teams.\n\n::: {#exr-koeien}\n### Oneway-ANOVA Koeiendataset\n\n-   Test eerst met een oneway-ANOVA of de rassen van elkaar verschillen in gemiddelde melkgift.\n-   Welke conclusie trek je uit de toets?\n-   Welke posthoctoets past bij deze dataset?\n:::\n\n## de functie emmeans\n\nde functie `emmeans()` zit in de *package* **emmeans**. Packages kan je installeren met de functie `install.packages`, waarbij je als argument de naamvan de package tussen \"\" moet zetten.\n\n::: {#exr-installemmeans}\n### emmeans installeren\n\n-   installeer de package emmeans\n:::\n\nMet de functie `emmeans` kan je van alles berekenen. Om het nog complexer te maken kan je met verschillende argumenten in de functie `emmeans()` dezelfde posthoctoets uitvoeren. Dat is goed om te beseffen als op internet op zoek gaat naar codes voor posthoctoets. Hier houden we een stijl aan die je voor iedere posthoctoets kan uitvoeren, uitgevoerd op bijna ieder statistisch model:\n\n`emmeans(fit, specs = ~ pairwise ~ variabele)`\n\nHierbij moet je voor **fit** de uitkomst van het statistisch model zetten, en voor **variable** de naam van je verklarende variabele waar je een posthoctoets op los wil laten. Eventueel kan je daar ook (voor een two-way-ANOVA) meerdere verklarende variabelen neerzetten, op dezelfde manier als in de functie `lm`, dus met een `+` of een `*` tussen de namen.\n\n### Tukey HSD\n\nHet resultaat bestaat uit twee onderdelen:\n\n-   Het gemiddelde effect van iedere factor (officieel de *estimated marginal means* genoemd, weet je gelijk waar de naam van de package vandaan komt). Van ieder effect is ook de standaardfout en het betrouwbaarheidsinterval gegeven.\n-   Daaronder staan de *contrasts*. Dat zijn de onderlinge vergelijken. Het verschil wordt gegeven en er wordt een t-toets uitgevoerd waarbij de overschrijdingskans gecorrigeerd is. Standaard wordt de TukeyHSD-correctie gebruikt.\n\nHier is de uitkomst van de posthoctoets voor de koeiendata:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n$emmeans\n ras emmean     SE df lower.CL upper.CL\n HF    2.95 0.0459  9     2.85     3.06\n MRY   3.21 0.0513  9     3.09     3.33\n RHF   2.97 0.0592  9     2.83     3.10\n\nConfidence level used: 0.95 \n\n$contrasts\n contrast  estimate     SE df t.ratio p.value\n HF - MRY   -0.2580 0.0688  9  -3.748  0.0114\n HF - RHF   -0.0147 0.0749  9  -0.196  0.9791\n MRY - RHF   0.2433 0.0784  9   3.105  0.0307\n\nP value adjustment: tukey method for comparing a family of 3 estimates \n```\n:::\n:::\n\n\n\nDe bovenste en onderste vergelijking zijn significant (p\\<0.05). Dus MRY verschilt significant van HF en RHF, maar HF en RHF verschillen onderling niet significant van elkaar.\n\n::: {#exr-tukey}\n### Tukey HSD posthoctoets uitvoeren\n\n-   Schrijf de code in een script voor het uitvoeren van bovenstaande Tukey HSD posthoctoets\n:::\n\n### Bonferroni\n\nWillen we nu een Bonferroni-posthoc uitvoeren, dan hoeven maar een argument toe te voegen:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemmeans(fit, specs = pairwise ~ variabele, adjust = \"bonf\")\n```\n:::\n\n\n\nDeze test is iets conservatiever (voorzichtiger) dus de p-waardes zijn een fractie hoger.\n\n::: {#exr-bonf}\n### Bonferroni posthoctoets uitvoeren\n\n-   Schrijf de code in een script voor het uitvoeren van de Bonferroni posthoctoets voor de koeiendataset\n:::\n\n### Dunnet's\n\nVoor de Dunnet's Posthoctoets gebruiken we als *specs* niet de pairwise, maar trt.vs.ctrl (\\*treatment versus control):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemmeans(fit, specs = trt.vs.ctrl ~ variabele)\n```\n:::\n\n\n\nDe functie pakt automatisch de eerste factor (hier **HF**) als controle.\n\nMet het argument \\`ref\\`\\` kan je aangeven welke factor je als controle wilt. In onderstaand geval willen we de tweede factor als controle:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemmeans(fit, specs = trt.vs.ctrl ~ ras, ref = 2)\n```\n:::\n\n\n\nEr is nog een variant voor als je de laatste factor als controle wilt. Dan moet je een k achter ctrl zetten:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemmeans(fit, specs = trt.vs.ctrlk ~ ras)\n```\n:::\n\n\n\n## Resultaten Posthoctoets in ggplot\n\nHet is gebruikelijk om in figuren met hoofdletters aan te geven welke groepen van elkaar verschillen. Kijk maar eens in een wetenschappelijk artikel waarin staafdiagrammen staan.\n\nAls we terug gaan naar het voorbeeld van de koeien, dan hebben we de volgende output uit de Tukey HSD posthoctoets:\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n$emmeans\n ras emmean     SE df lower.CL upper.CL\n HF    2.95 0.0459  9     2.85     3.06\n MRY   3.21 0.0513  9     3.09     3.33\n RHF   2.97 0.0592  9     2.83     3.10\n\nConfidence level used: 0.95 \n\n$contrasts\n contrast  estimate     SE df t.ratio p.value\n HF - MRY   -0.2580 0.0688  9  -3.748  0.0114\n HF - RHF   -0.0147 0.0749  9  -0.196  0.9791\n MRY - RHF   0.2433 0.0784  9   3.105  0.0307\n\nP value adjustment: tukey method for comparing a family of 3 estimates \n```\n:::\n:::\n\n\n\nJe ziet dat de volgorde van effect HF \\> RHF \\> MRY is. HF en RHF verschillen significant van MRY (p-waarde \\< 0,05), maar verschillen niet onderling (p-waarde = 0,9791). Normaal geef je de laagste waarde een A en significant hogere waarden de volgende letters in het alfabet. In dit geval krijgen:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(koeien, aes(ras, Melksnelheid)) +\n  stat_summary(geom = \"bar\", fill = \"lightblue\") +\n  stat_summary(geom = \"errorbar\", width = 0.3) +\n  stat_summary(geom = \"text\", label = c(\"A\", \"B\", \"A\"), vjust = -0.6, size  = 8) +\n  ylim(c(0, 4))\n```\n\n::: {.cell-output-display}\n![](Week2_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nDe functie `stat_summary` kan je ook gebruiken om tekst toe te voegen. Voordeel is dat die dezelfde datapunten meeneemt als de voorgaande regels code (voor *bar* en *errorbar*). Hierdoor komt de tekst op de goede plek. Je moet wel spelen met de code om de figuur netjes te maken. Ten eerst wil je de letter boven de staven hebben, dat doe je met het argument `vjust`. Negatieve waardes betekent omhoog, positieve waardes omlaag. De beste waarde is natuurlijk afhankelijk van hoe groot je foutenbalken zijn. Daarnaast wil je de letters ook groot genoeg hebben (naar eigen smaak), met het argument `size`. Maar hierdoor kunnen de letters voorbij de bovenkant gaan. Dat los je weer op door de schaal op de y-as te veranderen met de functie `ylim`.\n\n::: {#exr-CapLet}\n### Spielerei met ggplot\n\n-   Neem bovenstaande code over en past die aan naar eigen smaak. NB: bovenstaande figuur heeft als *theme* **theme_classic**. Zelf zet ik dat thema al bovenaan mijn script vast (na `library(tidyverse`)) met de functie `theme_set(theme_classic())`.\n:::\n\n## Opgaven hoofdstuk 15\n\n::: {#exr-postdocoefeningen}\n## **Practice Problems**\n\nGebruik uit onderstaande *Practice Problems* de datasets:\n\n15.1, 15.4, 15.8\n\nI.p.v. vragen uit het boek, met dezelfde dataset de volgende vragen beantwoorden:\n\n-   Data invoeren\n-   Scatterplot maken\n-   Hypotheses opstellen\n-   ANOVA uitvoeren, p-waarden opschrijven\n-   De juiste posthoc-toets uitvoeren\n-   Conclusies trekken\n:::\n",
    "supporting": [
      "Week2_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}